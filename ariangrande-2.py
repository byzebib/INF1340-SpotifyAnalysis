# -*- coding: utf-8 -*-
"""ariangrande.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IVc-9nARmPAaaKDxcBGHs9llNc7YSsdV
"""

# citations 
# Rohit Kumar Thakur, August 30th, "Spotify Data Visualization and Analysis using Python" Source code, # https://medium.com/geekculture/spotify-data-visualization-and-analysis-using-python-4af81c5531a7
# Dae Bardhoshi, September 30th, "Music System", Source Code,  # https://github.com/DeaBardhoshi/Data-Science-Projects/blob/main/Music%20System.ipynb

# access spotify to pull Ariana Grande music information
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import pandas as pd
import time

client_id = 'd1414013bbbe4f0ab817aff5a66a6c13' # use our personal spotify information to get into spotify 
client_secret = '0bca3a94e7d94fe8b30bda97a68ab224'

client_credentials_manager = SpotifyClientCredentials(client_id, client_secret)
sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

def getTrackIDs(user, playlist_id):
    ids = []
    playlist = sp.user_playlist(user, playlist_id)
    for item in playlist['tracks']['items']:
        track = item['track']
        ids.append(track['id'])
    return ids

ids = getTrackIDs('Ragave Vic', '0At1809AzgSQXbraEONTRw?si=7defeb467b5e4957') # personal spotify account and playlist 

print(len(ids))
print(ids)


def getTrackFeatures(id): # get properities/variables for data features 
  meta = sp.track(id)
  features = sp.audio_features(id)

  # make variables for the properities 
  name = meta['name']
  album = meta['album']['name']
  artist = meta['album']['artists'][0]['name']
  release_date = meta['album']['release_date']
  length = meta['duration_ms']
  popularity = meta['popularity']

  # account for all features/properities of songs 
  acousticness = features[0]['acousticness']
  danceability = features[0]['danceability']
  energy = features[0]['energy']
  instrumentalness = features[0]['instrumentalness']
  liveness = features[0]['liveness']
  loudness = features[0]['loudness']
  speechiness = features[0]['speechiness']
  tempo = features[0]['tempo']
  time_signature = features[0]['time_signature']

  track = [name, album, artist, release_date, length, popularity, danceability, acousticness, danceability, energy, instrumentalness, liveness, loudness, speechiness, tempo, time_signature]
  return track

# loop over the track ids 
tracks = []
for i in range(len(ids)):
  time.sleep(.5)
  track = getTrackFeatures(ids[i])
  tracks.append(track)

# create dataset
df = pd.DataFrame(tracks, columns = ['name', 'album', 'artist', 'release_date', 'length', 'popularity', 'danceability', 'acousticness', 'danceability', 'energy', 'instrumentalness', 'liveness', 'loudness', 'speechiness', 'tempo', 'time_signature'])
df.to_csv("spotify.csv", sep = ',')

# import pandas and matplotlib to analzye and visualize the daya
import pandas as pd
from matplotlib import pyplot as plt

data= pd.read_csv("arianagrande_spotify.csv") # open .cvs file on python
data # show data

#name and view data frame
df_data = pd.DataFrame(data)
df_data

# start cleaning the data 
sorted_df = df_data.sort_values('popularity', ascending = False).head(100) # sort data by least to most popularity to clean the data
sorted_two_df = df_data.sort_values('popularity', ascending = True) # return true when when it is sorted by popularity 
date = list(df_data.release_date) # dataframe will be sorted from oldest release date to latest 
for i in range(len(date)):
    date[i] = int(date[i][:4])
sorted_two_df

df_data['Year'] = date # sort by newest to oldest to clean the data
df_data

df_pre90 = df_data[df_data.Year <= 1990] # sort by release date 
df_post_90 = df_data[df_data.Year > 1990]
df_data

sorted_df.head() # check if its sorted

sorted_df['length'].value_counts().index.unique() # sort the index to clean the data

print(max(sorted_df['length'].value_counts().index.unique()), min(sorted_df['length'].value_counts().index.unique()))

def minutes_seconds(x): # change miliseconds into minutes and seconds 
    to_seconds = x/1000
    to_minutes = to_seconds/60
    return to_minutes # return length in minutes instead of miliseconds 

sorted_df['duration_minutes'] = sorted_df['length'].map(minutes_seconds) # sort by minutes 
sorted_df.head()

plt.hist(sorted_df['duration_minutes']);

sorted_df['time_signature'].value_counts().index.unique()

sorted_df.columns

sorted_df['energy'].unique()

sorted_df['artist'][:10]

sorted_df['artist'].unique()

sorted_df['danceability'].unique()

sorted_df.groupby(['name']).size().sort_values(ascending = False)

sorted_df[sorted_df['name'] == 'worst behavior']

len(sorted_df['name'].unique()) == len(sorted_df['name']) # check if all songs are unique, true means yes

import seaborn as sns

df_data['Period'] = df_data['Year'].map(lambda x: 'pre-90' if x<1990 else 'post-90')
sns.boxplot(x="energy", y="Period", data=df_data)
plt.title('Energy in post and pre 1990 songs');

# Commented out IPython magic to ensure Python compatibility.
# import numpy and pandas to determine analytics information 
import numpy as np
import pandas as pd
import scipy.stats as stats
# import seaborn and matplotlib for data visualization 
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
import plotly 
import plotly.express as px
# % matplotlib inline

df = pd.read_csv("arianagrande_spotify.csv", encoding='latin-1') # read python file 
df.head()

#data info
df.info()
#Check missing values
df.isnull().sum()

#check number of times charted by artist
df_numbercharted=df.groupby('artist').sum().sort_values('popularity', ascending=False)
df_numbercharted=df_numbercharted.reset_index()
df_numbercharted

px.bar(x='popularity', y='danceability', data_frame=df_numbercharted.head(7), title="Ariana Grande Popularity")

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline # create heat map for different properies and variables 
f,ax = plt.subplots(figsize=(14,10))
sns.heatmap(df.corr(),annot = True,fmt = ".1f",ax = ax)
plt.show()

# make line graph with correlations between popularity and dancability 
px.line(x='popularity', y='danceability', data_frame=df, title="Correlation between Popularity and Danceability")

# make line graph with correlations between dancability over the years 
px.line(x='release_date', y='popularity', data_frame=df, title="Danceability over the course of the Years")

# sort 
dfyear = df.groupby('release_date').sum().sort_values('popularity', ascending=False)
dfyear=dfyear.reset_index()

px.bar(x='release_date', y='popularity', data_frame=dfyear.head(7))

artistbypop = df.groupby('album').sum().sort_values('popularity' ,ascending=False)[:20]
artistbypop=artistbypop.reset_index()
#plot the graph
px.bar(x='album', y='popularity', data_frame=artistbypop, title="Ariana Grande's Most Popular Albums")

# make a bar graph for Ariana Grande's most popular songs 
artistbypop = df.groupby('name').sum().sort_values('popularity' ,ascending=False)[:20]
artistbypop=artistbypop.reset_index()

px.bar(x='name', y='popularity', data_frame=artistbypop, title="Ariana Grande's Most Popular Songs")

# make a bar graph for Ariana Grande's Most Danceable Songs
artistbypop = df.groupby('name').sum().sort_values('danceability' ,ascending=False)[:20]
artistbypop=artistbypop.reset_index()

px.bar(x='name', y='danceability', data_frame=artistbypop, title="Ariana Grande's Most Danceable Songs")

# make a bar graph for Ariana Grande's Most Acoustic Songs
artistbypop = df.groupby('name').sum().sort_values('acousticness' ,ascending=False)[:20]
artistbypop=artistbypop.reset_index()

px.bar(x='name', y='acousticness', data_frame=artistbypop, title="Ariana Grande's Most Acoustic Songs")

# make a bar graph for Ariana Grande's Most Energetic Songs
artistbypop = df.groupby('name').sum().sort_values('energy' ,ascending=False)[:20]
artistbypop=artistbypop.reset_index()

px.bar(x='name', y='energy', data_frame=artistbypop, title="Ariana Grande's Most Energetic Songs")

# make a bar graph for Ariana Grande's showing the Correlation Between Ariana Grande's Most Popular Songs and Their Release date
artistbypop = df.groupby('release_date').sum().sort_values('popularity' ,ascending=False)[:20]
artistbypop=artistbypop.reset_index()

px.bar(x='release_date', y='popularity', data_frame=artistbypop, title="Correlation Between Ariana Grande's Most Popular Songs and Their Release date")

# make a bar graph for Ariana Grande's Most Most Danceable Albums
artistbypop = df.groupby('album').sum().sort_values('danceability' ,ascending=False)[:20] # determine most dancabile albums 
artistbypop=artistbypop.reset_index()

px.bar(x='album', y='danceability', data_frame=artistbypop, title="Ariana Grande's Most Danceable Albums")

fig = plt.figure(figsize = (10, 10))
ax = fig.subplots()
df.album.value_counts()[:30].plot(ax=ax, kind = "pie")
ax.set_ylabel("")
ax.set_title("Top Ariana Grande albums based on popularity")
plt.show()